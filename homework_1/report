# Домашняя работа №2
#### Отладка программ на языке C с применением GDB 
##### Абушахманов Ирлан БПИ216 <ikhabushakhmanov@edu.hse.ru>

<br>
<br>
<br>

# План работы

1. Оценка работоспособность программы shell-sort, используемую в качестве домашнего задания.
2. Проверить корректность программы на наборе данных, вводимых в командной строке:
2 1 5 -12 3 -9. Все ли нормально?
3. Рассмотрение других тестовых наборов с целью определить, возможно ли некорректное поведение.
4. Проведение отладку и коррекции программы, в случае обнаружения некорректного поведения.
5. Формировка отчета с протоколом поиска ошибок, описанием сформированного тестового набора, откорректированной программой, если обнаружена и исправлена ошибка. 

<br>
<br>
<br>

## 1. Оценка программы 
<br>

```c
/* shell-sort.c - Сортировка Шелла */

#include <stdio.h>
#include <stdlib.h>

static void shell_sort(int a[], int size) {
  int i, j;
  int h = 1;

  do {
    h = h * 3 + 1;
  } while (h <= size);

  do {
    h /= 3;
    for (i = h; i < size; i++) {
      int v = a[i];
      for (j = i; j >= h && a[j - h] > v; j -= h) {
        a[j] = a[j - h];
      }
      if (i != j) {
        a[j] = v;
      }
    }
  } while (h != 1);
}

int main(int argc, char *argv[]) {
  int *a;
  int i;

  a = (int *)malloc((argc - 1) * sizeof(int));
  for (i = 0; i < argc - 1; i++) {
    a[i] = atoi(argv[i + 1]);
  }
  shell_sort(a, argc);
  printf("Output: ");
  for (i = 0; i < argc - 1; i++) {
    printf("%d ", a[i]);
  }
  printf("N\n");
  free(a);
  return 0;
}
```

Программа должна представлять из себя сортировку Шелла. 
Массив для сортировки передается в командную строку, массив передается в метод *shell_sort*, в котором происходит сортировка, далее вне метода производится вывод элементов массива и выход из программы.

<br>
<br>
<br>

## 2. Проверка программы
При вводе в командную строку массива 
```
[ 2, 1, 5, -12, 3, -9 ]
```
Метод *shell_sort* возвращает:
```
[ -12, -9, 1, 2, 3, 5 ]
```
Что, вообще говоря, верно.

<br>
<br>
<br>

## 3. Проверка программы на своих входных данных
Проверим следующие массив на корректность сортировки
```
[ 1, 2, 3, 4, 5, 6, 7 ]
[ 9, 23, 5, 1, 2, 5, 5, 3, -1, 34, 5, 4, 2 ]
[ 1 ]
```
На этих входных данных метод *shell_sort* возвращает:
```
[ 0, 1, 2, 3, 4, 5, 6 ]
[ -1, 0, 1, 2, 2, 3, 4, 5, 5, 5, 5, 9, 23 ]
[ 0 ]
```
Что, очевидно, не верно. Метод *shell_sort* делает почти корректную сортировку.
Видно, что куда-то "пропадает" самое большое число, а вместо него появляется ноль. 

<br>
<br>
<br>

## 4. Дебаг

Есть три потенциальных места, где мы можем терять данные:
1. Считывание данных с консоли
2. Метод *shell_sort*
3. Вывод в консоль


##### 4.1 Проверка ввода с консоли
Установим точку останова на метод main(), дойдем до линии, где завершается цикл заполнения массива и выведем его значения.

```gdb
(gdb) break 36
Breakpoint 1 at 0xa80: file shell-sort.c, line 37.
(gdb) r 9 23 5 1 2 5 5 3 -1 34 5 4 2
Starting program: /home/irlan/Desktop/2_homework/a.out 9 23 5 1 2 5 5 3 -1 34 5 4 2

Breakpoint 1, main (argc=14, argv=0xffffffffeed8) at shell-sort.c:37
37   shell_sort(a, argc);
(gdb) p *a@13
$1 = {9, 23, 5, 1, 2, 5, 5, 3, -1, 34, 5, 4, 2}
```

В консоли мы установили точку останова на 36 строчку - там уже отработал цикл считывания входных данных в массив a. Запускаем нашу программу и выводим в консоль значения принятых элементов - их ровно 13 и они ровно такие же, какие мы ввели в консоль.
Вывод: считывание с консоли работает корректно.

<br>
<br>

##### 4.1 Проверка метода *shell_sort*
Установим точку останова на 39 строке, где уже отработал метод сортировки.
Проверим, вернулись корректные данные или нет.
```gdb
(gdb) break 39
Breakpoint 1 at 0xa98: file shell-sort.c, line 40.
(gdb) r 9 23 5 1 2 5 5 3 -1 34 5 4 2
Starting program: /home/irlan/Desktop/2_homework/a.out 9 23 5 1 2 5 5 3 -1 34 5 4 2

Breakpoint 1, main (argc=14, argv=0xffffffffeed8) at shell-sort.c:40
40   for (i = 0; i < argc - 1; i++) {
(gdb) p *a@13
$1 = {-1, 0, 1, 2, 2, 3, 4, 5, 5, 5, 5, 9, 23}
```
Несложно заметить, что в массиве внезапно появился тот самый ноль, о котором говорилось в предыдущем пункте. Ошибка в методе.

Первым делом было приянто проверить переменные внутри метода и массив во время работы цикла
```gdb
(gdb) break 20
Breakpoint 1 at 0x998: file shell-sort.c, line 21.
(gdb) r 9 23 5 1 2 5 5 3 -1 34 5 4 2
Starting program: /home/irlan/Desktop/2_homework/a.out 9 23 5 1 2 5 5 3 -1 34 5 4 2

Breakpoint 1, shell_sort (a=0xaaaaaaab22a0, size=14) at shell-sort.c:21
21       if (i != j) {
(gdb) display *a@13
1: *a@13 = {9, 23, 5, 1, 2, 5, 5, 3, -1, 34, 5, 4, 2}
(gdb) c
Continuing.

Breakpoint 1, shell_sort (a=0xaaaaaaab22a0, size=14) at shell-sort.c:21
21       if (i != j) {
1: *a@13 = {0, 23, 5, 1, 2, 5, 5, 3, -1, 34, 5, 4, 2}
(gdb) c
Continuing.
```
Несложно заметить, что уже на первой внтуренней итерации мы получаем загадочный ноль, а переменные остаются корректными.
После долгих и изнурительных проверок измненния переменных было решено проверить переменную *size*, которая, к счастью, передавалась некорректно.
```gdb
(gdb) break 10
Breakpoint 1 at 0x8a0: file shell-sort.c, line 11.
(gdb) r 9 23 5 1 2 5 5 3 -1 34 5 4 2
Starting program: /home/irlan/Desktop/2_homework/a.out 9 23 5 1 2 5 5 3 -1 34 5 4 2

Breakpoint 1, shell_sort (a=0xaaaaaaab22a0, size=14) at shell-sort.c:11
11     h = h * 3 + 1;
(gdb) display size
1: size = 14
```
Видно, что длина, которую мы передаем в метод числом - n + 1, а по факту - n.
Проверим массивы, которые использовались ранее на корректность сортировки
```
[ 1, 2, 3, 4, 5, 6, 7 ]
[ 9, 23, 5, 1, 2, 5, 5, 3, -1, 34, 5, 4, 2 ]
[ 1 ]
```
На этих входных данных метод *shell_sort* возвращает:
```
[ 1, 2, 3, 4, 5, 6, 7 ]
[ -1, 1, 2, 2, 3, 4, 5, 5, 5, 5, 9, 23, 34 ]
[ 1 ]
```
Правильно!

<br>
<br>
<br>

## 5. Итог
В ходе выполнения дебага была выявлена ошибка, которая неправильно соритрует большинство тестов из-за некорректной передачи аргумента длины в метод.
Корректный вид программы:

```c
/* shell-sort.c - Сортировка Шелла */

#include <stdio.h>
#include <stdlib.h>

static void shell_sort(int a[], int size) {
  int i, j;
  int h = 1;

  do {
    h = h * 3 + 1;
  } while (h <= size);

  do {
    h /= 3;
    for (i = h; i < size; i++) {
      int v = a[i];
      for (j = i; j >= h && a[j - h] > v; j -= h) {
        a[j] = a[j - h];
      }
      if (i != j) {
        a[j] = v;
      }
    }
  } while (h != 1);
}

int main(int argc, char *argv[]) {
  int *a;
  int i;

  a = (int *)malloc((argc - 1) * sizeof(int));
  for (i = 0; i < argc - 1; i++) {
    a[i] = atoi(argv[i + 1]);
  }
  shell_sort(a, argc - 1);  // !!!
  printf("Output: ");
  for (i = 0; i < argc - 1; i++) {
    printf("%d ", a[i]);
  }
  printf("N\n");
  free(a);
  return 0;
}
```

## Большое спасибо!





